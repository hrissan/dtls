// Copyright (c) 2025, Grigory Buteyko aka Hrissan
// Licensed under the MIT License. See LICENSE for details.

package ciphersuite

import (
	"crypto/cipher"
	"encoding/binary"

	"github.com/hrissan/dtls/dtlserrors"
	"github.com/hrissan/dtls/record"
	"golang.org/x/crypto/chacha20"
	"golang.org/x/crypto/chacha20poly1305"
)

const symmetricKeysChaCha20Poly1305SealSize = 16

type SymmetricKeysChaCha20Poly1305 struct {
	SNKey   [32]byte
	Write   cipher.AEAD
	WriteIV [12]byte
}

func NewChacha20Poly1305(key []byte) cipher.AEAD {
	c, err := chacha20poly1305.New(key[:])
	if err != nil {
		panic("chacha20poly1305.NewCipher fails " + err.Error())
	}
	return c
}

func (keys *SymmetricKeysChaCha20Poly1305) EncryptSeqMask(cipherText []byte) ([2]byte, error) {
	if len(cipherText) < 16 {
		return [2]byte{}, dtlserrors.WarnCipherTextTooShortForSNDecryption
	}
	// [rfc9147: 4.2.3] mask is generated by treating the first 4 bytes of the ciphertext
	// as the block counter and the next 12 bytes as the nonce
	counter := binary.BigEndian.Uint32(cipherText)
	ci, err := chacha20.NewUnauthenticatedCipher(keys.SNKey[:], cipherText[4:])
	if err != nil {
		panic("failed to create chacha20 cipher")
	}
	var mask [64]byte
	ci.SetCounter(counter)
	ci.XORKeyStream(mask[:], mask[:])

	return [2]byte(mask[0:2]), nil
}

func (keys *SymmetricKeysChaCha20Poly1305) RecordOverhead() (AEADSealSize int, MinCiphertextSize int) {
	return symmetricKeysChaCha20Poly1305SealSize, 16
}

func (keys *SymmetricKeysChaCha20Poly1305) AEADEncrypt(seq uint64, datagramLeft []byte, hdrSize int, insideSize int) {
	iv := keys.WriteIV
	FillIVSequence(iv[:], seq)

	encrypted := keys.Write.Seal(datagramLeft[hdrSize:hdrSize], iv[:], datagramLeft[hdrSize:hdrSize+insideSize], datagramLeft[:hdrSize])
	if &encrypted[0] != &datagramLeft[hdrSize] {
		panic("gcm.Seal reallocated datagram storage")
	}
	if len(encrypted) != len(datagramLeft[hdrSize:hdrSize+insideSize+symmetricKeysAESSealSize]) {
		panic("gcm.Seal length mismatch")
	}
}

func (keys *SymmetricKeysChaCha20Poly1305) AEADDecrypt(hdr record.Ciphertext, seq uint64) (decrypted []byte, err error) {
	gcm := keys.Write
	iv := keys.WriteIV // copy, otherwise disaster

	FillIVSequence(iv[:], seq)
	decrypted, err = gcm.Open(hdr.Body[:0], iv[:], hdr.Body, hdr.Header)
	if err != nil {
		return nil, dtlserrors.WarnAEADDeprotectionFailed
	}
	if &decrypted[0] != &hdr.Body[0] {
		panic("gcm.Open reallocated datagram storage")
	}
	if len(decrypted) != len(hdr.Body)-symmetricKeysAESSealSize {
		panic("unexpected decrypted body size")
	}
	return decrypted, nil
}
